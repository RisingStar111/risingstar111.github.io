<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Template</title>
    <link rel="stylesheet" href="/base.css">
    <style>
        #canvasContainer {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-items: center;
            justify-items: center;
        }
    </style>
</head>
<body style="display: flex; flex-direction: column">
    <div id="header"></div>
    <h1>5x5 levels</h1>
    <div id="canvasContainerContainer" style="place-items: center;">
        <div id="canvasContainer">
            <canvas id="canvas" width=320 height=320 style="touch-action: none;"></canvas>
        </div>
    </div>
    <div id="buttonControls">
        <button id="newLevel">Random level</button>
        <label id="stepGoal">Optimal: 0</label>
        <br>
        <label>Use WASD or Arrow keys to move. R to restart. Push boxes to open a way to the goal in the fewest steps.</label>
        <br>
        <button id="moveUpButton">↑</button>
        <br>
        <button id="moveLeftButton">←</button>
        <button id="moveDownButton">↓</button>
        <button id="moveRightButton">→</button>
        <br>
        <button id="restartButton">Restart</button>
        <button id="undoButton">Undo</button>
        <br>
        <p id="stepCountText">Step: 0</p>
        <input type="range" min="0" max="0" id="stepSlider">
    </div>
    <div id="bonusOptions">
        <label><input type="checkbox" id="orientationToggle" checked>Randomise orientation</label>
        <label><input type="checkbox" id="automaticRandom">New level when optimal</label>
        <button id="optionsButton">Options</button>
    </div>
    <br>
    <div style="display: flex; justify-content: center;">
        <div style="min-width: 50%; max-width: 300px; text-align: left;">
            <p>We define a solution to be unique if it is not a subset of another solution (independant on what levels allow that solution), up to rotations and reflections. For 5x5 holeless, there are 56599 unique solutions, with the longest being 69 steps long. The game above has 56599 levels - one level per unique solution (but not guaranteeing that each level has only one solution).</p>
            <p>Levels were constructed via exhaustive backwards breadth-first search while ensuring the construction path is an optimal solution. Solutions weren't tracked during generation as the original goal was only to find and verify the longest level. Initially, a tree of all optimal paths through all generated levels was constructed, before pairwise checking for subsets and storing the maximal solutions (and a corresponding level). A particular implementation detail is that during generation, levels were compared (see below) against only levels with fewer steps taken - comparing against same-step levels in addition results in the tree of paths being incomplete, unless tracked during generation.</p>
            <p>To reduce the state space of the search, levels were discarded if they had been 'seen before', thus providing no new information about the space; the goal of the search is to find the longest optimal solution, which is certainly obtained if all possible routes are explored where the new level doesn't have a shorter solution (e.g. when traversing backwards, one may loop directly back to the exit, resulting in a trivially solution). A simple verification step is to use a standard foward running solver and check that the fastest solution is what it should be, but this is extremely costly. Instead, each new level is checked for an existing 'subset'. A subset of a level X is defined to be any level Y such that all possible backwards steps (recursively) from Y result in levels which have an optimal solution that is also a solution on the levels created by the same steps from X, and a level cannot be a subset if there are valid backward steps that don't exist on both X and Y (two levels may have the same solutions currently, but a different arrangement of blocks that allow diverging states later). A subset, if seen, also has an optimal solution that is strictly shorter, as the search is step-wise breadth-first.</p>
            <p>For a simplified version of Pathology where all blocks can be pushed in any direction, (only most?) subsets are given by a direct subset on the 'playable space' (non-wall tiles) of each level - if the playable space of level Y is contained in the playable space of level X, and all blocks, goals and the player are in the same place, then X is a subset of Y, and Y is discarded. When restricted blocks are introduced, the above still applies, but each block checks for a subset of pushable sides rather than exact equality (block A is a subset of block B if B has at least the same sides pushable as A).</p>
        </div>
    </div>
    <dialog id="optionsDialog">
        <input type="checkbox" id="fullWalls" checked>
        <label for="fullWalls">Wall-only blocks are filled in.</label>
        <br>
        <input type="checkbox" id="gridOutlines">
        <label for="gridOutlines">Show the block grid.</label>
        <br>
        <label for="touchControlMode">Touch control method:</label>
        <select id="touchControlMode">
            <option value="tap">Tap to move</option>
            <option value="swipe">Swipe to step</option>
            <option value="drag">Drag to move</option>
        </select>
        <br>
        <form method="dialog">
            <button>Close</button>
        </form>
    </dialog>

    <script src="options.js"></script>
    <script type="module">
        // a lot of this is duplicate from the editor, but js continues to make actually separating code awkward
        import {Level, Direction, Block, Board, Space} from './board.js'
        
        // interfaces(?) for the rust board, with associated static helpers
        let playLevel = new Level(); // created when loading a level
        Level.levelChangedCallback = onLevelChanged;
        // bind options controls
        // the options script should have been run first as script module => defer
        IOptions.bindToggle(document.getElementById("fullWalls"), 'fillWalls', drawBoard);
        IOptions.bindToggle(document.getElementById("gridOutlines"), 'outlineGrid', drawBoard);
        IOptions.bindValue(document.getElementById("touchControlMode"), 'moveMethod');
        // mouse control data
        let lastMouseHoverIndex = null;
        let deltaMouseX = null;
        let deltaMouseY = null;
        let lastMouseX = null;
        let lastMouseY = null;

        // canvas for rendering the level, both for edit mode and play mode
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // Set up button callbacks
        // global controls
        document.getElementById("optionsButton").onclick = displayOptions;
        // play mode controls
        document.getElementById("moveUpButton").onclick = () => playLevel.moveHandler(Direction.Up);
        document.getElementById("moveDownButton").onclick = () => playLevel.moveHandler(Direction.Down);
        document.getElementById("moveLeftButton").onclick = () => playLevel.moveHandler(Direction.Left);
        document.getElementById("moveRightButton").onclick = () => playLevel.moveHandler(Direction.Right);
        document.getElementById("restartButton").onclick = restartLevel;
        document.getElementById("undoButton").onclick = undoStep;
        document.getElementById("stepSlider").oninput = onSliderChange;
        document.getElementById("newLevel").onclick = generateLevel;

        function drawBoard() { // todo without the sizer buttons, probably a better method
            // allow page formatting to resize the grid to fit
            const gridContainer = document.getElementById("canvasContainer");
            gridContainer.style.gridTemplateColumns = 'minmax(0px, 1fr)';
            gridContainer.style.gridTemplateRows = 'minmax(0px, 1fr)';
            // make canvas view big to force grid to ?
            canvas.width = 1000;
            canvas.height = 1000;
            // force reflow and get pixel track sizes
            const gridSizes = window.getComputedStyle(gridContainer).grid.split(" ");
            // force a maximum size of 320px
            canvas.width = Math.min(320, parseInt(gridSizes[2]));
            canvas.height = Math.min(320, parseInt(gridSizes[0]));
            // set the grid to scale to the content
            gridContainer.style.gridTemplateColumns = 'auto';
            gridContainer.style.gridTemplateRows = 'auto';

            playLevel.drawToCanvas(canvas, ctx, PathologyOptions.outlineGrid, PathologyOptions.fillWalls);

            if (PathologyOptions.moveMethod == MoveMethods.Tap && lastMouseHoverIndex !== null) {
                let highlights = playLevel.board.indices_on_path_to_index(lastMouseHoverIndex);
                playLevel.drawHighlights(highlights, canvas, ctx);
            }
        }

        function onSliderChange() {
            playLevel.setStep(document.getElementById("stepSlider").value);
        }

        function onLevelChanged() {
            const length = playLevel.history.get_history_length() - 1;
            const current = playLevel.history.current_step;
            document.getElementById("stepSlider").max = length;
            document.getElementById("stepSlider").value = current;
            document.getElementById("stepCountText").innerHTML = `Steps: ${current}`;
            if (automaticRandomToggle.checked && playLevel.history.current_step == optimalStepcount && playLevel.board.get_space(playLevel.board.get_player()) == "goalSpace") {
                generateLevel();
            }
            drawBoard();
        }

        function displayOptions() {
            document.getElementById("optionsDialog").showModal();
        }

        function restartLevel() {
            playLevel.setStep(0);
            drawBoard();
        }

        function undoStep() {
            if (playLevel.history.current_step > 0) {
                playLevel.setStep(playLevel.history.current_step - 1);
            }
        }

        document.addEventListener('keydown', function (event) {
            // stackoverflow moment
            const direction = {
                "ArrowLeft"  : Direction.Left,
                "ArrowRight" : Direction.Right,
                "ArrowUp"    : Direction.Up,
                "ArrowDown"  : Direction.Down,
                "KeyW"       : Direction.Up,
                "KeyA"       : Direction.Left,
                "KeyS"       : Direction.Down,
                "KeyD"       : Direction.Right,
            }[event.code];
            if (direction !== undefined) {
                playLevel.moveHandler(direction);
            }
            if (event.code == "KeyR") {
                restartLevel();
            }
            if (event.code == "KeyZ") {
                undoStep();
            }
        });

        document.getElementById("canvas").addEventListener('pointerdown', (e) => {
            deltaMouseX = 0;
            deltaMouseY = 0;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        })
        document.getElementById("canvas").addEventListener('pointerup', (e) => {
            deltaMouseX = null;
            deltaMouseY = null;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        })
        document.getElementById("canvas").addEventListener('pointermove', (e) => {
            // TODO (make better this is bad code)
            const rect = canvas.getBoundingClientRect();
            let clickX = clamp((e.clientX - rect.left) / canvas.width, 0, 0.999);
            let clickY = clamp((e.clientY - rect.top) / canvas.height, 0, 0.999);
            const mouseIndex = playLevel.board.get_index(clickX, clickY);
            if (mouseIndex != lastMouseHoverIndex) {
                lastMouseHoverIndex = mouseIndex;
                drawBoard();
            }
            if (deltaMouseX !== null) {
                deltaMouseX += e.clientX - lastMouseX;
                deltaMouseY += e.clientY - lastMouseY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                if (PathologyOptions.moveMethod == MoveMethods.Swipe) {
                    if (Math.abs(deltaMouseX) > 128) {
                        playLevel.moveHandler(deltaMouseX < 0 ? Direction.Left : Direction.Right);
                        deltaMouseX = null;
                        deltaMouseY = null;
                    } else if (Math.abs(deltaMouseY) > 128) {
                        playLevel.moveHandler(deltaMouseY < 0 ? Direction.Up : Direction.Down);
                        deltaMouseX = null;
                        deltaMouseY = null;
                    }
                } else if (PathologyOptions.moveMethod == MoveMethods.Drag) {
                    if (Math.abs(deltaMouseX) > 64) {
                        playLevel.moveHandler(deltaMouseX < 0 ? Direction.Left : Direction.Right);
                        deltaMouseX = 0;
                    }
                    if (Math.abs(deltaMouseY) > 64) {
                        playLevel.moveHandler(deltaMouseY < 0 ? Direction.Up : Direction.Down);
                        deltaMouseY = 0;
                    }
                }
            }
        })
        document.getElementById("canvas").addEventListener('mouseleave', (e) => {
            lastMouseHoverIndex = null;
            drawBoard();
        })
        document.getElementById("canvas").addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / canvas.width;
            const clickY = (e.clientY - rect.top) / canvas.height;
            const clickIndex = playLevel.board.get_index(clickX, clickY);
            if (PathologyOptions.moveMethod == MoveMethods.Tap) {
                playLevel.history.move_to_index(clickIndex);
                playLevel.setStep(playLevel.history.current_step);
            }
        });

        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }

        let optimalStepcount = 0;
        let randomOrientationToggle = document.getElementById("orientationToggle");
        let automaticRandomToggle = document.getElementById("automaticRandom"); // TODO

        // load level binary
        const levelNum = 56599;
        let levelSize = 5 * 5;
        let levels = undefined;
        loadLevelData().then(buffer => {levels = new Int8Array(buffer); console.log("Loaded levels data."); generateLevel()});

        // encoded values are just sequential, map those to
        // 0-15: bits ON indicate pushable from the top, left, bottom, right (most to least sig bit)
        // 16: empty tile
        // 17: goal
        // 18: player
        // 19: hole // not used
        const tilemap = [16,  0, 15, 17, 18, 19,  1,  2,  4,  8,
                          3,  6, 12,  9, 14, 13, 11,  7,  5, 10];

        async function loadLevelData() {
            // if actually adding more level sets, probably good to look into external hosting
            const response = await fetch("level_batches/5x5holeless.bin");
            const buffer = await response.arrayBuffer();
            console.log("Got levels data.");
            return buffer
        }

        function generateLevel() {
            let levelIndex = randomInt(0, levelNum);
            optimalStepcount = levels[levelIndex];
            document.getElementById("stepGoal").innerHTML = `Optimal: ${optimalStepcount}`
            let grid = levels.slice(levelNum + levelSize * levelIndex, levelNum + levelSize * (levelIndex + 1));
            grid = grid.map(function (val) {return tilemap[val]});
            let board = Board.default(5, 5);
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] == 18) {
                    board.set_player(i);
                } else if (grid[i] == 17) {
                    board.set_space(i, Space.Goal);
                } else if (grid[i] < 16) {
                    board.set_block(i, Block.from_trbl_bytes(1 + ((grid[i] >> 3) & 1), 1 + (grid[i] & 1), 1 + ((grid[i] >> 1) & 1), 1 + ((grid[i] >> 2) & 1)));
                }
            }

            if (randomOrientationToggle.checked) {
                let rot = randomInt(0, 4);
                let flip = randomInt(0, 2);
                if (flip > 0) {
                    board.mirror();
                }
                while (rot > 0) {
                    board.rotate_ccw();
                    rot--;
                }
            }

            playLevel = new Level(board);
            playLevel.setStep(0);

            drawBoard();
        }

        function randomInt(lowInclusive, highExclusive) {
            return lowInclusive + Math.floor(Math.random() * (highExclusive - lowInclusive))
        }
    </script>
</body>
<script>
    // ChatGPT
    fetch('/header.html')
    .then(res => res.text())
    .then(html => {
        document.getElementById('header').innerHTML = html;
    });
</script>
</html>
