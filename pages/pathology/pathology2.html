<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Template</title>
    <link rel="stylesheet" href="/base.css">
    <style>
        canvas {
            background-color: rgb(9, 189, 9);
        }
        /* gpt-ed grid selection */
        gridSelect {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 5px;
        }
        .sprite {
            border: 1px solid #ccc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 32px;
            height: 32px;
        }
        .static {
            background: url('./sprites/modular.png');
        }
        .static[data-id="emptySpace"]  { background-position:  0     -34px; }
        .static[data-id="goalSpace"]   { background-position: -34px  -34px; }
        .static[data-id="playerTile"]  { background-position: -68px  -34px; }
        
        .selected {
            border: 2px solid red;
        }
        
        #canvasContainer {
            display: grid;
            grid-template-columns: 50px auto 50px;
            grid-template-rows: 50px auto 50px;
            align-items: center;
            justify-items: center;
        }
        .resizeButton {
            font-size: larger;
            padding: 0 0;
            width: 30px;
            height: 30px;
        }
    </style>
</head>
<body>
    <div id="header"></div>

    <template id="infopopup-template">
        <style>
            #container {
                position: relative;
                border: 2px solid black;
            }
            #details {
                padding: 5px;
                visibility: hidden;
                position: absolute;
                background-color: white;
                border: 2px solid black;
                z-index: 1;
                text-wrap-mode: nowrap; /* Not ideal but unsure what else exists */
            }
            #preview:hover {
                transition: 300ms linear;
                background-color: white;
            }
            #preview:hover + #details {
                transition-delay: 300ms;
                visibility: visible;
            }
        </style>
        <div id="container">
            <div id="preview">
                <slot name="text" id="preview">?</slot>
            </div>
            <div id="details">
                <slot>Information on Hover</slot>
            </div>
        </div>
    </template>

    <h1>Extended Pathology Level Editor</h1>
    <div id="canvasContainerContainer" style="place-items: center;">
        <div id="canvasContainer">
            <br>
            <div>
                <button class="resizeButton" id="addTop">+</button>
                <button class="resizeButton" id="subTop">-</button>
            </div>
            <br>
            <div>
                <button class="resizeButton" id="addLeft">+</button>
                <button class="resizeButton" id="subLeft">-</button>
            </div>
            <canvas id="canvas" width="320" height="320"></canvas>
            <div>
                <button class="resizeButton" id="addRight">+</button>
                <button class="resizeButton" id="subRight">-</button>
            </div>
            <br>
            <div>
                <button class="resizeButton" id="addBottom">+</button>
                <button class="resizeButton" id="subBottom">-</button>
            </div>
        </div>
    </div>
    Make a level with modular blocks
    <div id="buttonControls">
        <div id="editorControls">
            <button id="playButton">Play</button>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr">
                <div id="sideSelectorContainer" style="display: flex; flex-direction: column; align-items: end;" width="64">
                    <gridselect style="float: right">
                        <info-popup>Wall<br>Cannot be pushed</info-popup>
                        <info-popup>Basic<br>Can be pushed</info-popup>
                        <info-popup>Ice<br>Slides when pushed</info-popup>
                        <info-popup>Swap<br>Swaps with incoming entities</info-popup>
                        <info-popup>Hole<br>Deletes itself and incoming entities</info-popup>
                        <info-popup>PushSwap<br>Basic for the player<br>Swap for blocks</info-popup>
                    </gridselect>
                    <!-- Initialised by 'initisaliseSideSelector' -->
                </div>
                <div>
                    <canvas class="selected" id="blockPreview" style="display: inline" width="64", height="64"></canvas>
                    <br>
                    <input type="checkbox" id="clearPlacement">
                    <label for="clearPlacement">Remove blocks</label>
                    <br>
                    <input type="number" id="width" min="1" max="99" value="5">
                    <label for="width">Width</label>
                    <input type="number" id="height" min="1" max="99" value="5" style="margin-left: 10px">
                    <label for="height">Height</label>
                    <br>
                    <input type="range" min="0" max="0" id="editorSlider">
                    <br>
                    <button id="resizeButton">Reset</button>
                    <br>
                    <button id="dataButton">Level data</button>
                    <br>
                    <input type="checkbox" id="fullWalls" checked>
                    <label for="fullWalls">Fill walls</label>
                    <input type="checkbox" id="gridOutlines" style="margin-left: 10px">
                    <label for="gridOutlines">Grid</label>
                </div>
                <div style="display: flex; flex-direction: column; align-items: start;">
                    <gridselect style="float: left">
                        <info-popup>None<br>Empty space</info-popup>
                        <info-popup>Goal<br>Get the player here to win<br>[Winning not implemented]</info-popup>
                        <info-popup>Player<br>Can only have one<br>Cannot overlap a block</info-popup>
                    </gridselect>
                    <gridSelect id="spaceSelection" style="float: left">
                        <div class="sprite static" data-id="emptySpace"></div>
                        <div class="sprite static" data-id="goalSpace"></div>
                        <div class="sprite static" data-id="playerTile"></div>
                    </gridSelect>
                </div>
            </div>
        </div>
        <div id="playControls" style="display: none">
            <button id="editButton">Edit</button>
            <button id="moveUpButton">↑</button>
            <br>
            <button id="moveLeftButton">←</button>
            <button id="moveDownButton">↓</button>
            <button id="moveRightButton">→</button>
            <br>
            <button id="restartButton">Restart</button>
            <button id="undoButton">Undo</button>
            <br>
            <p id="stepCountText">Step: 0</p>
            <input type="range" min="0" max="0" id="stepSlider">
            <br>
            <input type="checkbox" id="highlightPath">
            <label for="highlightPath">Highlight path</label>
        </div>
    </div>
    <dialog id="levelDataDialog">
        Contains the current level data in a JSON format.<br>
        You can also copy images of the level directly and load them here.<br>
        <textarea id="levelDataText"></textarea>
        <form method="dialog">
            <button id="loadFromDataButton">Load JSON</button>
            <button id="loadFromImageButton">Load Image</button>
            <button id="cancelButton">Cancel</button>
        </form>
    </dialog>

    <script type="module">
        import init, { Board, Block, Direction, Space, BoardHistory } from './pkg/hello_wasm.js';

        async function run() {
            // Initialise the wasm - loads into memory but functions are only available while in this scope
            await init();

            // create wasm boards and handlers
            let editorBoard = newBoard(5, 5);
            let editorHistory = BoardHistory.from_board(editorBoard.clone());
            let playHistory = null;
            // top, right, bottom, left
            // definitely sacrifices some clarity but i like list manipulation what can i say
            let selectedSides = ["basicSide", "basicSide", "basicSide", "basicSide"];
            let space = "emptySpace";
            let placeLayer = "block";
            let clearPlacement = () => document.getElementById("clearPlacement").checked;
            let playing = false;
            let fullWall = () => document.getElementById("fullWalls").checked;
            let gridOutlines = () => document.getElementById("gridOutlines").checked;
            let highlightPath = () => document.getElementById("highlightPath").checked;
            let lastMouseHoverIndex = -1;

            const previewCanvas = document.getElementById("blockPreview");
            const previewCtx = previewCanvas.getContext("2d");
            previewCtx.imageSmoothingEnabled = false;

            // set up the editor canvas buttons

            // Set up button callbacks
            // functions within this module but outside the function are fair game
            document.getElementById("moveUpButton").onclick = () => moveHandler(Direction.Up);
            document.getElementById("moveDownButton").onclick = () => moveHandler(Direction.Down);
            document.getElementById("moveLeftButton").onclick = () => moveHandler(Direction.Left);
            document.getElementById("moveRightButton").onclick = () => moveHandler(Direction.Right);
            document.getElementById("restartButton").onclick = restartLevel;
            document.getElementById("undoButton").onclick = undoStep;
            document.getElementById("playButton").onclick = playLevel;
            document.getElementById("editButton").onclick = editLevel;
            document.getElementById("resizeButton").onclick = resizeLevel;
            document.getElementById("dataButton").onclick = displayLevelData;
            document.getElementById("loadFromDataButton").onclick = loadFromData;
            document.getElementById("loadFromImageButton").onclick = loadFromImage;
            document.getElementById("stepSlider").oninput = onSliderChange;
            document.getElementById("editorSlider").oninput = onSliderChange;
            document.getElementById("fullWalls").onclick = () => {drawBlockPreview(), drawBoard(playing ? playBoard : editorBoard)};
            document.getElementById("gridOutlines").onclick = () => {drawBoard(playing ? playBoard : editorBoard)};
            document.getElementById("addTop").onclick = () => add_side("top");
            document.getElementById("subTop").onclick = () => remove_side("top");
            document.getElementById("addLeft").onclick = () => add_side("left");
            document.getElementById("subLeft").onclick = () => remove_side("left");
            document.getElementById("addRight").onclick = () => add_side("right");
            document.getElementById("subRight").onclick = () => remove_side("right");
            document.getElementById("addBottom").onclick = () => add_side("bottom");
            document.getElementById("subBottom").onclick = () => remove_side("bottom");

            function add_side(side) {
                if (side == "top") {editorBoard.add_side_top()}
                if (side == "left") {editorBoard.add_side_left()}
                if (side == "right") {editorBoard.add_side_right()}
                if (side == "bottom") {editorBoard.add_side_bottom()}
                editorHistory.add_not_seen(editorBoard.clone());
                onEditorChange(editorHistory.current_step);
            }
            function remove_side(side) {
                if (side == "top") {editorBoard.remove_side_top()}
                if (side == "left") {editorBoard.remove_side_left()}
                if (side == "right") {editorBoard.remove_side_right()}
                if (side == "bottom") {editorBoard.remove_side_bottom()}
                editorHistory.add_not_seen(editorBoard.clone());
                onEditorChange(editorHistory.current_step);
            }

            function onSliderChange() {
                if (playing) {
                    onStepChange(document.getElementById("stepSlider").value);
                } else {
                    onEditorChange(document.getElementById("editorSlider").value);
                }
            }
            function onStepChange(new_step) {
                document.getElementById("stepSlider").max = playHistory.get_history_length() - 1;
                document.getElementById("stepSlider").value = new_step;
                document.getElementById("stepCountText").innerHTML = `Steps: ${new_step}`;
                playHistory.current_step = new_step;
                drawBoard(playHistory.get_current_board());
            }
            function onEditorChange(new_step) {
                document.getElementById("editorSlider").max = editorHistory.get_history_length() - 1;
                document.getElementById("editorSlider").value = new_step;
                editorHistory.current_step = new_step;
                editorBoard = editorHistory.get_current_board();
                document.getElementById("width").value = editorHistory.get_current_board().get_width();
                document.getElementById("height").value = editorHistory.get_current_board().get_height();
                drawBoard(editorHistory.get_current_board());
                drawData(editorBoard.serialize_bytes());
            }

            function displayLevelData() {
                document.getElementById("levelDataDialog").showModal();
                const levelTextArea = document.getElementById("levelDataText");
                const currentLevelData = editorBoard.serialize();
                levelTextArea.value = currentLevelData;
                levelTextArea.focus();
                levelTextArea.select();
            }
            function loadFromData() {
                const levelText = document.getElementById("levelDataText").value;
                editorBoard = Board.from_serialized(levelText);
                editorHistory.add_not_seen(editorBoard.clone());
                onEditorChange(editorHistory.current_step);
            }
            async function loadFromImage() { // what even is error handling
                const clipboardContents = await navigator.clipboard.read();
                for (const item of clipboardContents) {
                    for (const mimeType of item.types) {
                        if (mimeType === "image/png") {
                            const pngImage = new Image();
                            const blob = await item.getType("image/png");
                            pngImage.onload = () => {
                                ctx.drawImage(pngImage, 0, 0);
                                URL.revokeObjectURL(pngImage.src);
                                editorBoard = Board.from_serialized_bytes(dataFromImageData(ctx.getImageData(0, 0, canvas.width, canvas.height).data));
                                editorHistory.add_not_seen(editorBoard.clone());
                                onEditorChange(editorHistory.current_step);
                            }
                            pngImage.src = URL.createObjectURL(blob);
                        }
                    }
                }
            }

            function resizeLevel() {
                const newWidth = parseInt(document.getElementById("width").value);
                const newHeight = parseInt(document.getElementById("height").value);

                editorBoard = newBoard(newWidth, newHeight);
                editorHistory.add_not_seen(editorBoard.clone());
                onEditorChange(editorHistory.current_step);
            }
            function restartLevel() {
                playHistory.current_step = 0;
                drawBoard(playHistory.get_current_board());
            }

            function playLevel() {
                if (editorBoard.get_player() >= editorBoard.get_width() * editorBoard.get_height()) {
                    // player has been removed probably by resizing // underflow is active and player is a usize
                    window.prompt("Level must have a player");
                    return
                }
                document.getElementById("playControls").style.display = "block";
                document.getElementById("editorControls").style.display = "none";
                document.querySelectorAll(".resizeButton").forEach(element => {
                    element.style.display = "none";
                });

                playHistory = BoardHistory.from_board(editorBoard.clone());
                onStepChange(0);
                restartLevel();
                playing = true;
            }
            function editLevel() {
                document.getElementById("playControls").style.display = "none";
                document.getElementById("editorControls").style.display = "block";
                document.querySelectorAll(".resizeButton").forEach(element => {
                    element.style.display = "inline-block";
                });

                drawBoard(editorBoard);
                playing = false;
            }
            function newBoard(width, height) {
                return Board.default(width, height)
            }

            function undoStep() {
                if (playing) {
                    if (playHistory.current_step > 0) {
                        onStepChange(playHistory.current_step - 1);
                    }
                } else {
                    if (editorHistory.current_step > 0) {
                        onEditorChange(editorHistory.current_step - 1);
                    }
                }
            }

            function drawBlockPreview() {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height)
                if (fullWall() && arrayEqual(selectedSides, ["wallSide", "wallSide", "wallSide", "wallSide"])) {
                    // draw special fullblock wall
                    drawSpace("wallTile", [0, 0], 1, 1, previewCtx, previewCanvas);
                    return;
                }
                drawBlock(selectedSides, [0, 0], 1, 1, previewCtx, previewCanvas);
            }
            function drawBoard(board) {
                // resize canvas to a square ratio
                const baseSide = 320; // change this when allowing resizeable canvas
                let ratio = board.get_width() / board.get_height();
                if (ratio > 1) {
                    // shrink height
                    canvas.setAttribute("width", baseSide);
                    canvas.setAttribute("height",  baseSide / ratio);
                } else {
                    // shrink width
                    canvas.setAttribute("width", ratio * baseSide);
                    canvas.setAttribute("height",  baseSide);
                }
                // reset image smoothing to false because changing dimensions resets entire canvas
                ctx.imageSmoothingEnabled=false;

                let highlights = [];
                if (playing && highlightPath()) {
                    highlights = board.indices_on_path_to_index(lastMouseHoverIndex);
                }

                const width = board.get_width();
                const height = board.get_height();
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        const index = x + y * width;
                        const block = board.get_block_trbl(index);
                        const space = board.get_space(index);
                        drawSpace(space, [x, y], width, height, ctx, canvas);
                        if (gridOutlines()) {
                            drawSpace("gridOutline", [x, y], width, height, ctx, canvas);
                        }
                        if (playing && highlightPath()) { // better place to put this but haven't worked out everyhow i want highlights
                            if (highlights.includes(x + y*width)) {
                                drawSpace("spaceHighlight", [x, y], width, height, ctx, canvas);
                            }
                        }
                        if (block != null) {
                            // todo don't reuse
                            if (fullWall() && arrayEqual(block, ["wallSide", "wallSide", "wallSide", "wallSide"])) {
                                // draw special fullblock wall
                                drawSpace("wallTile", [x, y], width, height, ctx, canvas);
                                continue;
                            }
                            drawBlock(block, [x, y], width, height, ctx, canvas);
                        }
                    }
                }
                const playerIndex = board.get_player();
                drawSpace("playerTile", [playerIndex % width, (playerIndex - (playerIndex % width)) / width], width, height, ctx, canvas)
            }

            // no checks for if the data will fit
            function drawData(bytes) { //todo make this not bad // better but still don't like it
                let image = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let data = image.data;
                // IMPORTANT alpha channel gets reset to 255 on render so must be skipped
                // llm suggestion to extract pixel management into a function
                let p = 0;
                const setNextPixel = (v) => {
                    data[p] = (data[p] & ~0b11) | (v & 0b11);
                    // next rgb, skipping alpha (4th channel)
                    p++;
                    if (p % 4 == 3) {p++}
                }
                // first add bottom 16 bits of length (bytes is a Uint8Array, so is unextendable)
                // compiler unlikely to unroll this but not expensive
                for (let i = 0; i < 2 * 8; i += 2) {
                    setNextPixel(bytes.length >> i);
                }
                // pack bytes into bottom 2 bits of rgb of pixels
                for (let i = 0; i < bytes.length * 8; i += 2) {
                    setNextPixel(bytes[i >> 3] >> (i % 8));
                }
                ctx.putImageData(image, 0, 0);
            }
            // no checks for valid data
            function dataFromImageData(data) {
                let bytes = [];
                let numBytes = 0;
                let p = 0;
                const getNextBits = () => {
                    const o = data[p] & 0b11;
                    p++;
                    if (p % 4 == 3) {p++}
                    return o;
                }
                // get number of bytes from first 16 bits
                for (let i = 0; i < 2 * 8; i += 2) {
                    numBytes |= getNextBits() << i;
                }
                // read bytedata
                let byte = 0;
                for (let i = 0; i < numBytes * 8; i += 2) {
                    byte |= getNextBits() << (i % 8);
                    if (i % 8 == 6) {
                        bytes.push(byte);
                        byte = 0;
                    }
                }
                return bytes
            }

            // Initialise side selector
            {
                // insert side names
                let innerHtml = document.getElementById("sideSelectorContainer").innerHTML;
                // insert grid elements per side
                const sides = ["top", "left", "right", "bottom"];
                innerHtml += sides.map((side) => {
                        return `<gridSelect id="${side}SideSelection" style="float: right">
                            <canvas width="32" height="32" class="sprite" data-id="wallSide"></canvas>
                            <canvas width="32" height="32" class="sprite selected" data-id="basicSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="iceSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="swapSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="holeSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="pushSwapSide"></canvas>
                        </gridSelect>`
                    })
                    .join('');
                // set page html
                document.getElementById("sideSelectorContainer").innerHTML = innerHtml;

                // for each side selector
                for (let i = 0; i < 4; i++) {
                    // add unique selection callback
                    const side = sides[i];
                    const selector = document.getElementById(`${side}SideSelection`);
                    selector.addEventListener('click', (e) => {
                        const item = e.target.closest(".sprite");
                        if (!item) return;

                        // Remove previous selection
                        selector.querySelector(".selected").classList.remove("selected");

                        // Select the clicked one
                        item.classList.add("selected");

                        // Set global side variable
                        selectedSides[i] = item.dataset.id;

                        // Redraw preview
                        drawBlockPreview();
                    });
                    // blit rotated side sprite
                    selector.querySelectorAll(".sprite")
                        .forEach((item) => {
                            const itemCtx = item.getContext('2d');
                            drawTile(sideOffsets[item.dataset.id], 0, [0, 0], i*Math.PI/2, 1, 1, itemCtx, item);
                        });
                }
            } // end initialise side selector

            function assignSide(gridElement, event) { // still gpt-ed
                const item = event.target.closest(".sprite");
                if (!item) return;

                // Remove previous selection
                gridElement.querySelectorAll(".sprite.selected")
                        .forEach(el => el.classList.remove("selected"));

                // Select the clicked one
                item.classList.add("selected");

                // Emit selection
                return item.dataset.id;
            }

            const spaceSelection = document.getElementById("spaceSelection");
            spaceSelection.addEventListener('click', (e) => {
                space = assignSide(spaceSelection, e);
                placeLayer = "space";
                document.getElementById("blockPreview").classList.remove("selected")})
            const blockPreview = document.getElementById("blockPreview");
            blockPreview.addEventListener('click', (e) => {
                placeLayer = "block";
                blockPreview.classList.add("selected");
                spaceSelection.querySelectorAll(".sprite.selected").forEach(el => el.classList.remove("selected"));})

            function moveHandler(direction) {
                playHistory.step(direction);
                onStepChange(playHistory.current_step);
            }
            
            document.addEventListener('keydown', function (event) {
                // stackoverflow moment
                const direction = {
                    "ArrowLeft"  : Direction.Left,
                    "ArrowRight" : Direction.Right,
                    "ArrowUp"    : Direction.Up,
                    "ArrowDown"  : Direction.Down,
                    "KeyW"       : Direction.Up,
                    "KeyA"       : Direction.Left,
                    "KeyS"       : Direction.Down,
                    "KeyD"       : Direction.Right,
                }[event.code];
                if (playing) {
                    if (direction !== undefined) {
                        moveHandler(direction);
                    }

                    if (event.code == "KeyR") {
                        restartLevel();
                    }

                }
                if (event.code == "KeyZ") {
                    undoStep();
                }
            });

            document.getElementById("canvas").addEventListener('mousemove', (e) => {
                if (playing) {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / canvas.width;
                    const clickY = (e.clientY - rect.top) / canvas.height;
                    const mouseIndex = editorBoard.get_index(clickX, clickY);
                    if (mouseIndex != lastMouseHoverIndex) {
                        lastMouseHoverIndex = mouseIndex;
                        drawBoard(playHistory.get_current_board());
                    }
                }
            })
            document.getElementById("canvas").addEventListener('mouseleave', (e) => {
                if (playing) {
                    lastMouseHoverIndex = -1;
                    drawBoard(playHistory.get_current_board());
                }
            })
            document.getElementById("canvas").addEventListener('click', (e) => {
                if (!playing) {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / canvas.width;
                    const clickY = (e.clientY - rect.top) / canvas.height;
                    const clickIndex = editorBoard.get_index(clickX, clickY);
                    if (placeLayer == "block") {
                        editorBoard.set_block(clickIndex, clearPlacement() ? null : Block.from_trbl(selectedSides[0], selectedSides[1], selectedSides[2], selectedSides[3]));
                    } else if (placeLayer == "space") {
                        if (space == "playerTile") {
                            editorBoard.set_block(clickIndex, null);
                            editorBoard.set_player(clickIndex);
                        } else {
                            switch (space) {
                                case "emptySpace":
                                    editorBoard.set_space(clickIndex, Space.Empty);
                                    break;
                                case "goalSpace":
                                    editorBoard.set_space(clickIndex, Space.Goal);
                                    break;
                            
                                default:
                                    break;
                            }
                        }
                    }
                    editorHistory.add_not_seen(editorBoard.clone());
                    onEditorChange(editorHistory.current_step);
                }
            });

            drawBlockPreview();
            drawBoard(editorBoard);
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        const modularImg = new Image();
        modularImg.src = "sprites/modular.png";
        
        const sideOffsets = {
            "wallSide" : 68,
            "basicSide" : 0,
            "iceSide" : 34,
            "swapSide" : 102,
            "holeSide" : 136,
            "pushSwapSide" : 170,
            }
        const spaceOffsets = {
            "emptySpace" : 0,
            "goalSpace" : 34,
            "playerTile" : 68,
            "wallTile" : 102,
            "gridOutline" : 136,
            "spaceHighlight" : 170,
            }
        function drawBlock(blockSides, gridPos, gridWidth, gridHeight, ctx, canvas) {
            for (let i = 0; i < 4; i++) {
                drawTile(sideOffsets[blockSides[i]], 0, gridPos, i*Math.PI/2, gridWidth, gridHeight, ctx, canvas);
            }
        }
        function drawSpace(space, gridPos, gridWidth, gridHeight, ctx, canvas) {
            drawTile(spaceOffsets[space], 34, gridPos, 0, gridWidth, gridHeight, ctx, canvas)
        }

        function drawTile(spriteXOffset, spriteYOffset, gridPos, angle, gridWidth, gridHeight, ctx, canvas) {
            // grid to canvas position
            const canvasX = gridPos[0] * (canvas.width / gridWidth);
            const canvasY = gridPos[1] * (canvas.height / gridHeight);
            const tileWidth = canvas.width / gridWidth;
            const tileHeight = canvas.height / gridHeight;
            const spriteSize = 32;
            // render image from spritesheet
            ctx.translate(canvasX + tileWidth/2, canvasY + tileHeight/2);
            ctx.rotate(angle);
            ctx.translate(-tileWidth/2, -tileHeight/2);
            ctx.drawImage(modularImg, spriteXOffset, spriteYOffset, spriteSize, spriteSize, 0, 0, tileWidth, tileHeight);
            ctx.translate(tileWidth/2, tileHeight/2);
            ctx.rotate(-angle);
            ctx.translate(-canvasX - tileWidth/2, -canvasY - tileHeight/2);
        }

        // doesn't work on nested items
        // length must be the same - this includes undefined items and having items assigned to 'different indexes' since js arrays are fake
        function arrayEqual(arrayLeft, arrayRight) {
            if (arrayLeft.length != arrayRight.length) { return false }
            for (let i = 0; i < arrayLeft.length; i++) {
                if (arrayLeft[i] != arrayRight[i]) { return false }
            }
            return true
        }

        // make sure the initial draw events work
        if (modularImg.complete) {
            run();
        } else {
            modularImg.onload = run;
        }

        customElements.define(
            "info-popup",
            class extends HTMLElement {
                constructor() {
                super();
                let template = document.getElementById("infopopup-template");
                let templateContent = template.content;

                const shadowRoot = this.attachShadow({ mode: "open" });
                shadowRoot.appendChild(document.importNode(templateContent, true));
                }
            });
    </script>
</body>

<script>
    // ChatGPT
    fetch('/header.html')
    .then(res => res.text())
    .then(html => {
        document.getElementById('header').innerHTML = html;
    });
</script>
</html>
