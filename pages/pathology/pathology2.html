<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Template</title>
    <style>
        /* Add any CSS styles here */
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        #canvasContainer {
            position: relative;
        }
        canvas {
            border: 1px solid #ccc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .selected {
            border: 2px solid red;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
        }
        .small {
            padding: 5px 5px;
        }
        /* gpt-ed grid selection */
        gridSelect {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 5px;
        }
        .sprite {
            border: 1px solid #ccc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 32px;
            height: 32px;
        }
        .sprite.selected {
            border: 2px solid red;
        }
        .static {
            background: url('./sprites/modular.png');
        }
        .static[data-id="emptySpace"]  { background-position:  0     -34px; }
        .static[data-id="goalSpace"]   { background-position: -34px  -34px; }
        .static[data-id="playerTile"]  { background-position: -68px  -34px; }
    </style>
</head>
<body>
    <!--#include file="/header.html"-->
    <h1>5x5 levels</h1>
    <div id="canvasContainer">
        <canvas id="canvas" width="320" height="320"></canvas>
        <br>
        <label>Make a level with modular blocks</label>
    </div>
    <div id="buttonControls">
        <div id="editorControls">
            <button id="playButton">Play</button>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr">
                <div id="sideSelectorContainer">
                    <!-- Initialised by 'initisaliseSideSelector' -->
                </div>
                <div>
                    <canvas class="selected" id="blockPreview" style="display: inline" width="64", height="64"></canvas>
                    <br>
                    <input type="checkbox" id="clearPlacement">
                    <label for="clearPlacement">Remove blocks</label>
                    <br>
                    <input type="number" id="width" min="1" value="5">
                    <label for="width">Width</label>
                    <input type="number" id="height" min="1" value="5">
                    <label for="height">Height</label>
                    <br>
                    <input type="range" min="0" max="0" id="editorSlider">
                    <br>
                    <button id="resizeButton">Reset</button>
                    <br>
                    <button id="dataButton">Level data</button>
                    <br>
                    <button class="small" id="addTop">+</button>
                    Top
                    <button class="small" id="subTop">-</button>
                    <br>
                    <button class="small" id="addLeft">+</button>
                    Left
                    <button class="small" id="subLeft">-</button>
                    <button class="small" id="addRight">+</button>
                    Right
                    <button class="small" id="subRight">-</button>
                    <br>
                    <button class="small" id="addBottom">+</button>
                    Bottom
                    <button class="small" id="subBottom">-</button>
                </div>
                <div>
                    <p style="float: left">None Goal Player</p>
                    <gridSelect id="spaceSelection" style="float: left">
                        <div class="sprite static" data-id="emptySpace"></div>
                        <div class="sprite static" data-id="goalSpace"></div>
                        <div class="sprite static" data-id="playerTile"></div>
                    </gridSelect>
                </div>
            </div>
        </div>
        <div id="playControls" style="display: none">
            <button id="editButton">Edit</button>
            <button id="moveUpButton">↑</button>
            <br>
            <button id="moveLeftButton">←</button>
            <button id="moveDownButton">↓</button>
            <button id="moveRightButton">→</button>
            <br>
            <button id="restartButton">Restart</button>
            <button id="undoButton">Undo</button>
            <br>
            <p id="stepCountText">Step: 0</p>
            <input type="range" min="0" max="0" id="stepSlider">
        </div>
    </div>
    <dialog id="levelDataDialog">
        <textarea id="levelDataText"></textarea>
        <form method="dialog">
            <button id="loadFromDataButton">Close</button>
        </form>
    </dialog>

    <script type="module">
        import init, { Board, Block, Direction, Space, BoardHistory } from './pkg/hello_wasm.js';

        async function run() {
            // Initialise the wasm - loads into memory but functions are only available while in this scope
            await init();

            // create wasm boards and handlers
            let editorBoard = newBoard(5, 5);
            let editorHistory = BoardHistory.from_board(editorBoard.clone());
            let playHistory = null;
            // top, right, bottom, left
            // definitely sacrifices some clarity but i like list manipulation what can i say
            let selectedSides = ["wallSide", "wallSide", "wallSide", "wallSide"];
            let space = "emptySpace";
            let placeLayer = "block";
            let clearPlacement = () => document.getElementById("clearPlacement").checked;
            let playing = false;

            const previewCanvas = document.getElementById("blockPreview");
            const previewCtx = previewCanvas.getContext("2d");
            previewCtx.imageSmoothingEnabled = false;

            // set up the editor canvas buttons

            // Set up button callbacks
            // functions within this module but outside the function are fair game
            document.getElementById("moveUpButton").onclick = () => moveHandler(Direction.Up);
            document.getElementById("moveDownButton").onclick = () => moveHandler(Direction.Down);
            document.getElementById("moveLeftButton").onclick = () => moveHandler(Direction.Left);
            document.getElementById("moveRightButton").onclick = () => moveHandler(Direction.Right);
            document.getElementById("restartButton").onclick = restartLevel;
            document.getElementById("undoButton").onclick = undoStep;
            document.getElementById("playButton").onclick = playLevel;
            document.getElementById("editButton").onclick = editLevel;
            document.getElementById("resizeButton").onclick = resizeLevel;
            document.getElementById("dataButton").onclick = displayLevelData;
            document.getElementById("loadFromDataButton").onclick = loadFromData;
            document.getElementById("stepSlider").oninput = onSliderChange;
            document.getElementById("editorSlider").oninput = onSliderChange;
            document.getElementById("addTop").onclick = () => add_side("top");
            document.getElementById("subTop").onclick = () => remove_side("top");
            document.getElementById("addLeft").onclick = () => add_side("left");
            document.getElementById("subLeft").onclick = () => remove_side("left");
            document.getElementById("addRight").onclick = () => add_side("right");
            document.getElementById("subRight").onclick = () => remove_side("right");
            document.getElementById("addBottom").onclick = () => add_side("bottom");
            document.getElementById("subBottom").onclick = () => remove_side("bottom");

            function add_side(side) {
                if (side == "top") {editorBoard.add_side_top()}
                if (side == "left") {editorBoard.add_side_left()}
                if (side == "right") {editorBoard.add_side_right()}
                if (side == "bottom") {editorBoard.add_side_bottom()}
                editorHistory.add_not_seen(editorBoard.clone());
                onEditorChange(editorHistory.current_step);
            }
            function remove_side(side) {
                if (side == "top") {editorBoard.remove_side_top()}
                if (side == "left") {editorBoard.remove_side_left()}
                if (side == "right") {editorBoard.remove_side_right()}
                if (side == "bottom") {editorBoard.remove_side_bottom()}
                editorHistory.add_not_seen(editorBoard.clone());
                onEditorChange(editorHistory.current_step);
            }

            function onSliderChange() {
                if (playing) {
                    onStepChange(document.getElementById("stepSlider").value);
                } else {
                    onEditorChange(document.getElementById("editorSlider").value);
                }
            }
            function onStepChange(new_step) {
                document.getElementById("stepSlider").max = playHistory.get_history_length() - 1;
                document.getElementById("stepSlider").value = new_step;
                document.getElementById("stepCountText").innerHTML = `Steps: ${new_step}`;
                playHistory.current_step = new_step;
                drawBoard(playHistory.get_current_board());
            }
            function onEditorChange(new_step) {
                document.getElementById("editorSlider").max = editorHistory.get_history_length() - 1;
                document.getElementById("editorSlider").value = new_step;
                editorHistory.current_step = new_step;
                editorBoard = editorHistory.get_current_board();
                drawBoard(editorHistory.get_current_board());
            }

            function displayLevelData() {
                document.getElementById("levelDataDialog").showModal();
                const levelTextArea = document.getElementById("levelDataText");
                const currentLevelData = editorBoard.serialize();
                levelTextArea.value = currentLevelData;
                levelTextArea.focus();
                levelTextArea.select();
            }
            function loadFromData() {
                const levelText = document.getElementById("levelDataText").value;
                editorBoard = Board.from_serialized(levelText);
                drawBoard(editorBoard);
            }

            function resizeLevel() {
                const newWidth = parseInt(document.getElementById("width").value);
                const newHeight = parseInt(document.getElementById("height").value);

                editorBoard = newBoard(newWidth, newHeight);
                drawBoard(editorBoard);
            }
            function restartLevel() {
                playHistory.current_step = 0;
                drawBoard(playHistory.get_current_board());
            }

            function playLevel() {
                if (editorBoard.get_player() >= editorBoard.get_width() * editorBoard.get_height()) {
                    // player has been removed probably by resizing // underflow is active and player is a usize
                    window.prompt("Level must have a player");
                    return
                }
                document.getElementById("playControls").style.display = "block";
                document.getElementById("editorControls").style.display = "none";

                playHistory = BoardHistory.from_board(editorBoard.clone());
                onStepChange(0);
                restartLevel();
                playing = true;
            }
            function editLevel() {
                document.getElementById("playControls").style.display = "none";
                document.getElementById("editorControls").style.display = "block";

                drawBoard(editorBoard);
                playing = false;
            }
            function newBoard(width, height) {
                return Board.default(width, height)
            }

            function undoStep() {
                if (playing) {
                    if (playHistory.current_step > 0) {
                        onStepChange(playHistory.current_step - 1);
                    }
                } else {
                    if (editorHistory.current_step > 0) {
                        onEditorChange(editorHistory.current_step - 1);
                    }
                }
            }

            function drawBlockPreview() {
                drawBlock(selectedSides, [0, 0], 1, 1, previewCtx, previewCanvas);
            }
            function drawBoard(board) {
                // resize canvas to a square ratio
                const baseSide = 320; // change this when allowing resizeable canvas
                let ratio = board.get_width() / board.get_height();
                if (ratio > 1) {
                    // shrink height
                    canvas.setAttribute("width", baseSide);
                    canvas.setAttribute("height",  baseSide / ratio);
                } else {
                    // shrink width
                    canvas.setAttribute("width", ratio * baseSide);
                    canvas.setAttribute("height",  baseSide);
                }
                // reset image smoothing to false because changing dimensions resets entire canvas
                ctx.imageSmoothingEnabled=false;

                const width = board.get_width();
                const height = board.get_height();
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        const index = x + y * width;
                        const block = board.get_block_trbl(index);
                        const space = board.get_space(index);
                        drawSpace(space, [x, y], width, height, ctx, canvas);
                        if (block != null) {
                            drawBlock(block, [x, y], width, height, ctx, canvas);
                        }
                    }
                }
                const playerIndex = board.get_player();
                drawSpace("playerTile", [playerIndex % width, (playerIndex - (playerIndex % width)) / width], width, height, ctx, canvas)
            }

            // Initialise side selector
            {
                // insert side names
                let innerHtml = "<p style=\"float: right\">Wall Basic Ice Swap Hole Puap</p>";
                // insert grid elements per side
                const sides = ["top", "left", "right", "bottom"];
                innerHtml += sides.map((side) => {
                        return `<gridSelect id="${side}SideSelection" style="float: right">
                            <canvas width="32" height="32" class="sprite selected" data-id="wallSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="basicSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="iceSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="swapSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="holeSide"></canvas>
                            <canvas width="32" height="32" class="sprite" data-id="pushSwapSide"></canvas>
                        </gridSelect>`
                    })
                    .join('');
                // set page html
                document.getElementById("sideSelectorContainer").innerHTML = innerHtml;

                // for each side selector
                for (let i = 0; i < 4; i++) {
                    // add unique selection callback
                    const side = sides[i];
                    const selector = document.getElementById(`${side}SideSelection`);
                    selector.addEventListener('click', (e) => {
                        const item = e.target.closest(".sprite");
                        if (!item) return;

                        // Remove previous selection
                        selector.querySelector(".selected").classList.remove("selected");

                        // Select the clicked one
                        item.classList.add("selected");

                        // Set global side variable
                        selectedSides[i] = item.dataset.id;

                        // Redraw preview
                        drawBlockPreview();
                    });
                    // blit rotated side sprite
                    selector.querySelectorAll(".sprite")
                        .forEach((item) => {
                            const itemCtx = item.getContext('2d');
                            drawTile(sideOffsets[item.dataset.id], 0, [0, 0], i*Math.PI/2, 1, 1, itemCtx, item);
                        });
                }
            } // end initialise side selector

            function assignSide(gridElement, event) { // still gpt-ed
                const item = event.target.closest(".sprite");
                if (!item) return;

                // Remove previous selection
                gridElement.querySelectorAll(".sprite.selected")
                        .forEach(el => el.classList.remove("selected"));

                // Select the clicked one
                item.classList.add("selected");

                // Emit selection
                return item.dataset.id;
            }

            const spaceSelection = document.getElementById("spaceSelection");
            spaceSelection.addEventListener('click', (e) => {
                space = assignSide(spaceSelection, e);
                placeLayer = "space";
                document.getElementById("blockPreview").classList.remove("selected")})
            const blockPreview = document.getElementById("blockPreview");
            blockPreview.addEventListener('click', (e) => {
                placeLayer = "block";
                blockPreview.classList.add("selected");
                spaceSelection.querySelectorAll(".sprite.selected").forEach(el => el.classList.remove("selected"));})

            function moveHandler(direction) {
                playHistory.step(direction);
                onStepChange(playHistory.current_step);
            }
            
            document.addEventListener('keydown', function (event) {
                // stackoverflow moment
                const direction = {
                    "ArrowLeft"  : Direction.Left,
                    "ArrowRight" : Direction.Right,
                    "ArrowUp"    : Direction.Up,
                    "ArrowDown"  : Direction.Down,
                    "KeyW"       : Direction.Up,
                    "KeyA"       : Direction.Left,
                    "KeyS"       : Direction.Down,
                    "KeyD"       : Direction.Right,
                }[event.code];
                if (playing) {
                    if (direction !== undefined) {
                        moveHandler(direction);
                    }

                    if (event.code == "KeyR") {
                        restartLevel();
                    }

                }
                if (event.code == "KeyZ") {
                    undoStep();
                }
            });

            document.getElementById("canvas").addEventListener('click', (e) => {
                if (!playing) {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / canvas.width;
                    const clickY = (e.clientY - rect.top) / canvas.height;
                    const clickIndex = editorBoard.get_index(clickX, clickY);
                    if (placeLayer == "block") {
                        editorBoard.set_block(clickIndex, clearPlacement() ? null : Block.from_trbl(selectedSides[0], selectedSides[1], selectedSides[2], selectedSides[3]));
                    } else if (placeLayer == "space") {
                        if (space == "playerTile") {
                            editorBoard.set_block(clickIndex, null);
                            editorBoard.set_player(clickIndex);
                        } else {
                            switch (space) {
                                case "emptySpace":
                                    editorBoard.set_space(clickIndex, Space.Empty);
                                    break;
                                case "goalSpace":
                                    editorBoard.set_space(clickIndex, Space.Goal);
                                    break;
                            
                                default:
                                    break;
                            }
                        }
                    }
                    editorHistory.add_not_seen(editorBoard.clone());
                    onEditorChange(editorHistory.current_step);
                }
            });

            drawBlockPreview();
            drawBoard(editorBoard);
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        const modularImg = new Image();
        modularImg.src = "sprites/modular.png";

        const sideOffsets = {
            "wallSide" : 68,
            "basicSide" : 0,
            "iceSide" : 34,
            "swapSide" : 102,
            "holeSide" : 136,
            "pushSwapSide" : 170,
            }
        const spaceOffsets = {
            "emptySpace" : 0,
            "goalSpace" : 34,
            "playerTile" : 68,
            }
        function drawBlock(blockSides, gridPos, gridWidth, gridHeight, ctx, canvas) {
            for (let i = 0; i < 4; i++) {
                drawTile(sideOffsets[blockSides[i]], 0, gridPos, i*Math.PI/2, gridWidth, gridHeight, ctx, canvas);
            }
        }
        function drawSpace(space, gridPos, gridWidth, gridHeight, ctx, canvas) {
            drawTile(spaceOffsets[space], 34, gridPos, 0, gridWidth, gridHeight, ctx, canvas)
        }

        function testlog(gridWidth, canvas) {
            const canvasX = gridPos[0] * (canvas.width / gridWidth);
            console.log(canvasX);
        }

        function drawTile(spriteXOffset, spriteYOffset, gridPos, angle, gridWidth, gridHeight, ctx, canvas) {
            // grid to canvas position
            const canvasX = gridPos[0] * (canvas.width / gridWidth);
            const canvasY = gridPos[1] * (canvas.height / gridHeight);
            const tileWidth = canvas.width / gridWidth;
            const tileHeight = canvas.height / gridHeight;
            const spriteSize = 32;
            // render image from spritesheet
            ctx.translate(canvasX + tileWidth/2, canvasY + tileHeight/2);
            ctx.rotate(angle);
            ctx.translate(-tileWidth/2, -tileHeight/2);
            ctx.drawImage(modularImg, spriteXOffset, spriteYOffset, spriteSize, spriteSize, 0, 0, tileWidth, tileHeight);
            ctx.translate(tileWidth/2, tileHeight/2);
            ctx.rotate(-angle);
            ctx.translate(-canvasX - tileWidth/2, -canvasY - tileHeight/2);
        }

        // make sure the initial draw events work
        if (modularImg.complete) {
            run();
        } else {
            modularImg.onload = run;
        }
    </script>
</body>
</html>
