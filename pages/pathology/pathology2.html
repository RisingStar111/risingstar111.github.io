<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Template</title>
    <link rel="stylesheet" href="/base.css">
    <style>
        canvas {
            background-color: rgb(0, 196, 12);
        }
        /* gpt-ed grid selection */
        blockselect {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 5px;
        }
        spaceselect {
            display: grid;
            grid-template-columns: repeat(3, 32px);
            gap: 5px;
        }
        .sprite {
            border: 1px solid #ccc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 32px;
            height: 32px;
        }
        .static {
            background: url('./sprites/modular.png');
        }
        .static[data-id="emptySpace"]  { background-position:  0     -34px; }
        .static[data-id="goalSpace"]   { background-position: -34px  -34px; }
        .static[data-id="playerTile"]  { background-position: -68px  -34px; }
        
        .selected {
            border: 2px solid red;
        }
        
        #canvasContainer {
            display: grid;
            grid-template-columns: 50px 1fr 50px;
            grid-template-rows: 50px 1fr 50px;
            align-items: center;
            justify-items: center;
        }
        .resizeButton {
            font-size: larger;
            padding: 0 0;
            width: 30px;
            height: 30px;
        }
    </style>
</head>
<body>
    <div id="header"></div>

    <template id="infopopup-template">
        <style>
            #container {
                position: relative;
                border: 2px solid black;
            }
            #details {
                padding: 5px;
                visibility: hidden;
                position: fixed;
                background-color: white;
                border: 2px solid black;
                z-index: 1;
                text-wrap-mode: nowrap; /* Not ideal but unsure what else exists */
            }
            #preview:hover {
                transition: 300ms linear;
                background-color: white;
            }
            #preview:hover + #details {
                transition-delay: 300ms;
                visibility: visible;
            }
        </style>
        <div id="container">
            <div id="preview">
                <slot name="text" id="preview">?</slot>
            </div>
            <div id="details">
                <slot>Information on Hover</slot>
            </div>
        </div>
    </template>

    <h1>Extended Pathology Level Editor</h1>
    <div id="canvasContainerContainer" style="place-items: center;">
        <div id="canvasContainer">
            <br>
            <div>
                <button class="resizeButton" id="addTop">+</button>
                <button class="resizeButton" id="subTop">-</button>
            </div>
            <button id="optionsButton">Options</button>
            <div>
                <button class="resizeButton" id="addLeft">+</button>
                <button class="resizeButton" id="subLeft">-</button>
            </div>
            <canvas id="canvas" width=320 height=320 style="touch-action: none;"></canvas>
            <div>
                <button class="resizeButton" id="addRight">+</button>
                <button class="resizeButton" id="subRight">-</button>
            </div>
            <br>
            <div>
                <button class="resizeButton" id="addBottom">+</button>
                <button class="resizeButton" id="subBottom">-</button>
            </div>
        </div>
    </div>
    Make a level with modular blocks
    <div id="buttonControls">
        <div id="editorControls">
            <button id="playButton">Play</button>
            <div style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: center;">
                <div id="sideSelectorContainer" style="flex: 0; display: flex; flex-direction: column; align-items: center;">
                    <blockselect style="float: right">
                        <info-popup>Wall<br>Cannot be pushed</info-popup>
                        <info-popup>Basic<br>Can be pushed</info-popup>
                        <info-popup>Ice<br>Slides when pushed</info-popup>
                        <info-popup>Swap<br>Swaps with incoming entities</info-popup>
                        <info-popup>Hole<br>Deletes itself and incoming entities</info-popup>
                        <info-popup>PushSwap<br>Basic for the player<br>Swap for blocks</info-popup>
                    </blockselect>
                    <!-- Initialised by 'initisaliseSideSelector' -->
                </div>
                <div style="flex: 0 0 max-content; align-items: center;">
                    <canvas class="selected" id="blockPreview" style="display: inline" width="64" height="64"></canvas>
                    <br>
                    <input type="checkbox" id="clearPlacement">
                    <label for="clearPlacement">Remove blocks</label>
                    <br>
                    <input type="number" id="width" min="1" max="99" value="5">
                    <label for="width">Width</label>
                    <input type="number" id="height" min="1" max="99" value="5" style="margin-left: 10px">
                    <label for="height">Height</label>
                    <br>
                    <input type="range" min="0" max="0" id="editorSlider">
                    <br>
                    <button id="resizeButton">Reset</button>
                    <br>
                    <button id="dataButton">Level Data</button>
                </div>
                <div style="flex: 0; display: flex; flex-direction: column; align-items: center;">
                    <spaceselect style="float: left">
                        <info-popup>None<br>Empty space</info-popup>
                        <info-popup>Goal<br>Get the player here to win<br>[Winning not implemented]</info-popup>
                        <info-popup>Player<br>Can only have one<br>Cannot overlap a block</info-popup>
                    </spaceselect>
                    <spaceselect id="spaceSelection" style="float: left">
                        <div class="sprite static" data-id="emptySpace"></div>
                        <div class="sprite static" data-id="goalSpace"></div>
                        <div class="sprite static" data-id="playerTile"></div>
                    </spaceselect>
                </div>
            </div>
        </div>
        <div id="playControls" style="display: none">
            <button id="editButton">Edit</button>
            <button id="moveUpButton">↑</button>
            <br>
            <button id="moveLeftButton">←</button>
            <button id="moveDownButton">↓</button>
            <button id="moveRightButton">→</button>
            <br>
            <button id="restartButton">Restart</button>
            <button id="undoButton">Undo</button>
            <br>
            <p id="stepCountText">Step: 0</p>
            <input type="range" min="0" max="0" id="stepSlider">
        </div>
    </div>
    <dialog id="levelDataDialog">
        Contains the current level data in a JSON format.<br>
        You can also copy images of the level directly and load them here.<br>
        <textarea id="levelDataText"></textarea>
        <form method="dialog">
            <button id="loadFromDataButton">Load JSON</button>
            <button id="saveToImageButton">Save Image</button>
            <button id="loadFromImageButton">Load Image</button>
            <button id="cancelButton">Cancel</button>
        </form>
    </dialog>
    <dialog id="optionsDialog">
        <input type="checkbox" id="fullWalls" checked>
        <label for="fullWalls">Wall-only blocks are filled in.</label>
        <br>
        <input type="checkbox" id="gridOutlines">
        <label for="gridOutlines">Show the block grid.</label>
        <br>
        <label for="touchControlMode">Touch control method:</label>
        <select id="touchControlMode">
            <option value="tapMove">Tap to move</option>
            <option value="swipeMove">Swipe to step</option>
            <option value="dragMove">Drag to move</option>
        </select>
        <br>
        <form method="dialog">
            <button>Close</button>
        </form>
    </dialog>

    <script type="module">
        import {Level, Direction, Block} from './board.js'
        
        // interfaces(?) for the rust board, with associated static helpers
        let editorLevel = new Level();
        let playLevel; // created from editorLevel when transferring to play mode
        Level.levelChangedCallback = onLevelChanged;
        // editor control data
        // top, right, bottom, left
        // definitely sacrifices some clarity but i like list manipulation what can i say
        let selectedSides = ["basicSide", "basicSide", "basicSide", "basicSide"];
        let space = "emptySpace";
        let placeLayer = "block";
        let playing = false;
        // toggle state getters // the return value does change, but the function is const
        const clearPlacement = () => document.getElementById("clearPlacement").checked;
        const fullWall = () => document.getElementById("fullWalls").checked;
        const gridOutlines = () => document.getElementById("gridOutlines").checked;
        const touchControlMode = () => document.getElementById("touchControlMode").value;
        // mouse control data
        let lastMouseHoverIndex = null;
        let deltaMouseX = null;
        let deltaMouseY = null;
        let lastMouseX = null;
        let lastMouseY = null;

        // canvas for rendering the level, both for edit mode and play mode
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        // canvas for previewing currently constructed block
        const previewCanvas = document.getElementById("blockPreview");
        const previewCtx = previewCanvas.getContext("2d");
        previewCtx.imageSmoothingEnabled = false;

        // Set up button callbacks
        // global controls
        document.getElementById("optionsButton").onclick = displayOptions;
        document.getElementById("gridOutlines").onclick = drawBoard;
        document.getElementById("fullWalls").onclick = () => {drawBlockPreview(), drawBoard()};
        // play mode controls
        document.getElementById("moveUpButton").onclick = () => playLevel.moveHandler(Direction.Up);
        document.getElementById("moveDownButton").onclick = () => playLevel.moveHandler(Direction.Down);
        document.getElementById("moveLeftButton").onclick = () => playLevel.moveHandler(Direction.Left);
        document.getElementById("moveRightButton").onclick = () => playLevel.moveHandler(Direction.Right);
        document.getElementById("restartButton").onclick = restartLevel;
        document.getElementById("undoButton").onclick = undoStep;
        document.getElementById("editButton").onclick = editLevel;
        document.getElementById("stepSlider").oninput = onSliderChange;
        // edit mode controls
        document.getElementById("playButton").onclick = goPlayLevel;
        document.getElementById("resizeButton").onclick = resizeLevel;
        document.getElementById("editorSlider").oninput = onSliderChange;
        document.getElementById("dataButton").onclick = displayLevelData;
        document.getElementById("loadFromDataButton").onclick = loadFromData;
        document.getElementById("saveToImageButton").onclick = saveToImage;
        document.getElementById("loadFromImageButton").onclick = loadFromImage;
        // board resizers
        document.getElementById("addTop").onclick = () => editorLevel.add_side("top");
        document.getElementById("subTop").onclick = () => editorLevel.remove_side("top");
        document.getElementById("addLeft").onclick = () => editorLevel.add_side("left");
        document.getElementById("subLeft").onclick = () => editorLevel.remove_side("left");
        document.getElementById("addRight").onclick = () => editorLevel.add_side("right");
        document.getElementById("subRight").onclick = () => editorLevel.remove_side("right");
        document.getElementById("addBottom").onclick = () => editorLevel.add_side("bottom");
        document.getElementById("subBottom").onclick = () => editorLevel.remove_side("bottom");

        function activeLevel() {
            return playing ? playLevel : editorLevel;
        }

        function drawBoard() {
            // allow page formatting to resize the grid to fit
            const gridContainer = document.getElementById("canvasContainer");
            gridContainer.style.gridTemplateColumns = '50px minmax(0px, 1fr) 50px';
            gridContainer.style.gridTemplateRows = '50px minmax(0px, 1fr) 50px';
            // make canvas view big to force grid to ?
            canvas.width = 1000;
            canvas.height = 1000;
            // force reflow and get pixel track sizes
            const gridSizes = window.getComputedStyle(gridContainer).grid.split(" ");
            // force a maximum size of 320px
            canvas.width = Math.min(320, parseInt(gridSizes[5]));
            canvas.height = Math.min(320, parseInt(gridSizes[1]));
            // set the grid to scale to the content
            gridContainer.style.gridTemplateColumns = '50px auto 50px';
            gridContainer.style.gridTemplateRows = '50px auto 50px';

            (activeLevel()).drawToCanvas(canvas, ctx, gridOutlines(), fullWall());

            if (playing && touchControlMode() == "tapMove" && lastMouseHoverIndex !== null) {
                let highlights = playLevel.board.indices_on_path_to_index(lastMouseHoverIndex);
                playLevel.drawHighlights(highlights, canvas, ctx);
            }
        }

        function onSliderChange() {
            if (playing) { // TODO coordinate sliders better
                (activeLevel()).setStep(document.getElementById("stepSlider").value);
            } else {
                (activeLevel()).setStep(document.getElementById("editorSlider").value);
            }
        }

        function onLevelChanged() {
            const active = activeLevel();
            const length = active.history.get_history_length() - 1;
            const current = active.history.current_step;
            if (playing) {
                document.getElementById("stepSlider").max = length;
                document.getElementById("stepSlider").value = current;
                document.getElementById("stepCountText").innerHTML = `Steps: ${current}`;
            } else {
                document.getElementById("editorSlider").max = length;
                document.getElementById("editorSlider").value = current;
                document.getElementById("width").value = active.width;
                document.getElementById("height").value = active.height;
            }
            drawBoard();
        }

        function displayOptions() {
            document.getElementById("optionsDialog").showModal();
        }
        function displayLevelData() {
            document.getElementById("levelDataDialog").showModal();
            const levelTextArea = document.getElementById("levelDataText");
            const currentLevelData = editorLevel.board.serialize();
            levelTextArea.value = currentLevelData;
            levelTextArea.focus();
            levelTextArea.select();
        }
        function loadFromData() {
            const levelText = document.getElementById("levelDataText").value;
            editorLevel.loadText(levelText);
        }
        async function saveToImage() {
            const blob = await (activeLevel()).generateDataImageBlob();
            navigator.clipboard.write([new ClipboardItem({[blob.type]: blob})]);
        }
        async function loadFromImage() { // what even is error handling
            const clipboardContents = await navigator.clipboard.read();
            for (const item of clipboardContents) {
                for (const mimeType of item.types) {
                    if (mimeType === "image/png") {
                        const pngImage = new Image();
                        const blob = await item.getType("image/png");
                        pngImage.onload = () => {
                            // TODO use offscreenCanvas
                            canvas.setAttribute("width", pngImage.width);
                            canvas.setAttribute("height", pngImage.height);
                            ctx.drawImage(pngImage, 0, 0);
                            URL.revokeObjectURL(pngImage.src);
                            editorLevel.loadBinary(Level.dataFromImageData(ctx.getImageData(0, 0, pngImage.width, pngImage.height).data, canvas, ctx));
                        }
                        pngImage.src = URL.createObjectURL(blob);
                    }
                }
            }
        }

        function resizeLevel() {
            const newWidth = parseInt(document.getElementById("width").value);
            const newHeight = parseInt(document.getElementById("height").value);
            editorLevel.loadDefault(newWidth, newHeight);
        }
        function restartLevel() {
            playLevel.history.current_step = 0;
            drawBoard();
        }

        function goPlayLevel() {
            if (editorLevel.board.get_player() >= editorLevel.width * editorLevel.height) {
                // player has been removed probably by resizing // underflow is active and player is a usize
                window.prompt("Level must have a player");
                return
            }
            document.getElementById("playControls").style.display = "block";
            document.getElementById("editorControls").style.display = "none";
            document.querySelectorAll(".resizeButton").forEach(element => {
                element.style.display = "none";
            });

            playing = true;
            playLevel = new Level(editorLevel.board.clone());
            playLevel.setStep(0);
        }
        function editLevel() {
            document.getElementById("playControls").style.display = "none";
            document.getElementById("editorControls").style.display = "block";
            document.querySelectorAll(".resizeButton").forEach(element => {
                element.style.display = "inline-block";
            });

            playing = false;
            drawBoard();
        }

        function undoStep() {
            const active = activeLevel();
            if (active.history.current_step > 0) {
                active.setStep(active.history.current_step - 1);
            }
        }

        function drawBlockPreview() {
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height)
            if (fullWall() && selectedSides.every((side) => {return side == "wallSide"})) {
                Level.drawSpace("wallTile", [0, 0], 1, 1, previewCtx, previewCanvas);
            } else {
                Level.drawBlock(selectedSides, [0, 0], 1, 1, previewCtx, previewCanvas);
            }
        }

        // Initialise side selector
        {
            // insert side names
            let innerHtml = document.getElementById("sideSelectorContainer").innerHTML;
            // insert grid elements per side
            const sides = ["top", "left", "right", "bottom"];
            innerHtml += sides.map((side) => {
                    return `<blockselect id="${side}SideSelection" style="float: right">
                        <canvas width="32" height="32" class="sprite" data-id="wallSide"></canvas>
                        <canvas width="32" height="32" class="sprite selected" data-id="basicSide"></canvas>
                        <canvas width="32" height="32" class="sprite" data-id="iceSide"></canvas>
                        <canvas width="32" height="32" class="sprite" data-id="swapSide"></canvas>
                        <canvas width="32" height="32" class="sprite" data-id="holeSide"></canvas>
                        <canvas width="32" height="32" class="sprite" data-id="pushSwapSide"></canvas>
                    </blockselect>`
                })
                .join('');
            // set page html
            document.getElementById("sideSelectorContainer").innerHTML = innerHtml;

            // for each side selector
            for (let i = 0; i < 4; i++) {
                // add unique selection callback
                const side = sides[i];
                const selector = document.getElementById(`${side}SideSelection`);
                selector.addEventListener('click', (e) => {
                    const item = e.target.closest(".sprite");
                    if (!item) return;

                    // Remove previous selection
                    selector.querySelector(".selected").classList.remove("selected");

                    // Select the clicked one
                    item.classList.add("selected");

                    // Set global side variable
                    selectedSides[i] = item.dataset.id;

                    // Redraw preview
                    drawBlockPreview();
                });
                // blit rotated side sprite
                selector.querySelectorAll(".sprite")
                    .forEach((item) => {
                        const itemCtx = item.getContext('2d');
                        Level.drawTile(Level.sideOffsets[item.dataset.id], 0, [0, 0], i*Math.PI/2, 1, 1, itemCtx, item);
                    });
            }
        } // end initialise side selector

        function assignSide(gridElement, event) { // still gpt-ed
            const item = event.target.closest(".sprite");
            if (!item) return;

            // Remove previous selection
            gridElement.querySelectorAll(".sprite.selected")
                    .forEach(el => el.classList.remove("selected"));

            // Select the clicked one
            item.classList.add("selected");

            // Emit selection
            return item.dataset.id;
        }

        const spaceSelection = document.getElementById("spaceSelection");
        spaceSelection.addEventListener('click', (e) => {
            space = assignSide(spaceSelection, e);
            placeLayer = "space";
            document.getElementById("blockPreview").classList.remove("selected")})
        const blockPreview = document.getElementById("blockPreview");
        blockPreview.addEventListener('click', (e) => {
            placeLayer = "block";
            blockPreview.classList.add("selected");
            spaceSelection.querySelectorAll(".sprite.selected").forEach(el => el.classList.remove("selected"));})
            
        document.addEventListener('keydown', function (event) {
            // stackoverflow moment
            const direction = {
                "ArrowLeft"  : Direction.Left,
                "ArrowRight" : Direction.Right,
                "ArrowUp"    : Direction.Up,
                "ArrowDown"  : Direction.Down,
                "KeyW"       : Direction.Up,
                "KeyA"       : Direction.Left,
                "KeyS"       : Direction.Down,
                "KeyD"       : Direction.Right,
            }[event.code];
            if (playing) {
                if (direction !== undefined) {
                    playLevel.moveHandler(direction);
                }

                if (event.code == "KeyR") {
                    restartLevel();
                }

            }
            if (event.code == "KeyZ") {
                undoStep();
            }
        });

        document.getElementById("canvas").addEventListener('pointerdown', (e) => {
            if (playing) {
                deltaMouseX = 0;
                deltaMouseY = 0;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        })
        document.getElementById("canvas").addEventListener('pointerup', (e) => {
            if (playing) {
                deltaMouseX = null;
                deltaMouseY = null;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        })
        document.getElementById("canvas").addEventListener('pointermove', (e) => {
            if (playing) {
                // TODO (make better this is bad code)
                const rect = canvas.getBoundingClientRect();
                const clickX = (e.clientX - rect.left) / canvas.width;
                const clickY = (e.clientY - rect.top) / canvas.height;
                const mouseIndex = editorLevel.board.get_index(clickX, clickY);
                if (mouseIndex != lastMouseHoverIndex) {
                    lastMouseHoverIndex = mouseIndex;
                    drawBoard();
                }
                if (deltaMouseX !== null) {
                    deltaMouseX += e.clientX - lastMouseX;
                    deltaMouseY += e.clientY - lastMouseY;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    if (touchControlMode() == "swipeMove") {
                        if (Math.abs(deltaMouseX) > 128) {
                            if (deltaMouseX < 0) {
                                playLevel.moveHandler(Direction.Left);
                            } else {
                                playLevel.moveHandler(Direction.Right);
                            }
                            deltaMouseX = null;
                            deltaMouseY = null;
                        }
                        if (Math.abs(deltaMouseY) > 128) {
                            if (deltaMouseY < 0) {
                                playLevel.moveHandler(Direction.Up);
                            } else {
                                playLevel.moveHandler(Direction.Down);
                            }
                            deltaMouseX = null;
                            deltaMouseY = null;
                        }
                    } else if (touchControlMode() == "dragMove") {
                        if (Math.abs(deltaMouseX) > 64) {
                            if (deltaMouseX < 0) {
                                playLevel.moveHandler(Direction.Left);
                            } else {
                                playLevel.moveHandler(Direction.Right);
                            }
                            deltaMouseX = 0;
                        }
                        if (Math.abs(deltaMouseY) > 64) {
                            if (deltaMouseY < 0) {
                                playLevel.moveHandler(Direction.Up);
                            } else {
                                playLevel.moveHandler(Direction.Down);
                            }
                            deltaMouseY = 0;
                        }
                    }
                }
            }
        })
        document.getElementById("canvas").addEventListener('mouseleave', (e) => {
            if (playing) {
                lastMouseHoverIndex = null;
                drawBoard();
            }
        })
        document.getElementById("canvas").addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / canvas.width;
            const clickY = (e.clientY - rect.top) / canvas.height;
            const clickIndex = editorLevel.board.get_index(clickX, clickY);
            if (!playing) {
                if (e.ctrlKey) {
                    // copy block at click
                    const clickedBlock = editorLevel.board.get_block_trbl(clickIndex);
                    if (clickedBlock != null) {
                        selectedSides = clickedBlock;
                        drawBlockPreview();
                    }
                }
                else {
                    // TODO this is patch code atm
                    let board = editorLevel.board.clone();
                    if (placeLayer == "block") {
                        board.set_block(clickIndex, clearPlacement() ? null : Block.from_trbl(selectedSides[0], selectedSides[1], selectedSides[2], selectedSides[3]));
                    } else if (placeLayer == "space") {
                        if (space == "playerTile") {
                            board.set_block(clickIndex, null);
                            board.set_player(clickIndex);
                        } else {
                            switch (space) {
                                case "emptySpace":
                                    board.set_space(clickIndex, Space.Empty);
                                    break;
                                case "goalSpace":
                                    board.set_space(clickIndex, Space.Goal);
                                    break;
                            
                                default:
                                    break;
                            }
                        }
                    }
                    editorLevel.history.add_not_seen(board.clone());
                    editorLevel.setStep(editorLevel.history.current_step);
                }
            // playing
            } else {
                if (touchControlMode() == "tapMove") {
                    playLevel.history.move_to_index(clickIndex);
                    playLevel.setStep(playLevel.history.current_step);
                }
            }
        });

        customElements.define(
            "info-popup",
            class extends HTMLElement {
                constructor() {
                    super();
                    let template = document.getElementById("infopopup-template");
                    let templateContent = template.content;

                    this.attachShadow({ mode: "open" });
                    this.shadowRoot.appendChild(document.importNode(templateContent, true));
                }

                // gpt
                connectedCallback() {
                    const details = this.shadowRoot.querySelector("#details");
                    const preview = this.shadowRoot.querySelector("#preview");
                    preview.addEventListener('pointerenter', () => { requestAnimationFrame(() => {
                        const hostRect = this.getBoundingClientRect();
                        const rect = details.getBoundingClientRect();
                        
                        const left = Math.max(0, Math.min(hostRect.left, window.innerWidth - rect.width));
                        const top = Math.max(0, Math.min(hostRect.bottom, window.innerHeight - rect.height));

                        details.style.left = `${left}px`;
                        details.style.top = `${top}px`;
                        })});
                }
            });
            
        drawBlockPreview(); // may need to check if modularimg is loaded but that's now in board.js::Level
        drawBoard();
    </script>
</body>

<script>
    // ChatGPT
    fetch('/header.html')
    .then(res => res.text())
    .then(html => {
        document.getElementById('header').innerHTML = html;
    });
</script>
</html>
